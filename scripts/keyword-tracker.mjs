#!/usr/bin/env node

/**
 * üîç Keyword Position Tracker
 * Tracks keyword rankings and competitor analysis
 */

import fs from 'fs';
import path from 'path';

const CACHE_DIR = '.seo-cache';
const KEYWORDS_FILE = 'data/keywords.json';
const COMPETITORS_FILE = 'data/competitors.json';

// Ensure cache directory exists
if (!fs.existsSync(CACHE_DIR)) {
  fs.mkdirSync(CACHE_DIR, { recursive: true });
}

async function loadKeywords() {
  if (!fs.existsSync(KEYWORDS_FILE)) {
    console.warn('‚ö†Ô∏è Keywords file not found, using defaults');
    return {
      head_keywords: ['beauty jobs', 'nail technician jobs', 'emvi app'],
      long_tail_keywords: ['nail technician jobs near me', 'beauty salon careers'],
      location_keywords: ['beauty jobs los angeles', 'nail jobs new york']
    };
  }
  
  return JSON.parse(fs.readFileSync(KEYWORDS_FILE, 'utf8'));
}

async function loadCompetitors() {
  if (!fs.existsSync(COMPETITORS_FILE)) {
    console.warn('‚ö†Ô∏è Competitors file not found, using defaults');
    return {
      direct_competitors: [
        { name: 'Indeed', url: 'https://www.indeed.com/jobs?q=beauty' },
        { name: 'StyleSeat', url: 'https://www.styleseat.com' }
      ]
    };
  }
  
  return JSON.parse(fs.readFileSync(COMPETITORS_FILE, 'utf8'));
}

async function simulateRankingCheck(keyword, site = 'emvi.app') {
  // Simulate SERP position checking (would use real SERP API in production)
  console.log(`üîç Checking ranking for "${keyword}"...`);
  
  // Simulate realistic ranking data
  const basePosition = Math.floor(Math.random() * 100) + 1;
  const variation = Math.floor(Math.random() * 10) - 5; // -5 to +5 variance
  
  return {
    keyword,
    site,
    position: Math.max(1, Math.min(100, basePosition + variation)),
    timestamp: new Date().toISOString(),
    search_volume: Math.floor(Math.random() * 10000) + 500,
    difficulty: Math.floor(Math.random() * 100) + 1,
    serp_features: ['featured_snippet', 'people_also_ask', 'local_pack'][Math.floor(Math.random() * 3)]
  };
}

async function checkCompetitorRankings(keywords, competitors) {
  console.log('üèÅ Checking competitor rankings...');
  
  const results = [];
  
  for (const keyword of keywords.slice(0, 5)) { // Limit for simulation
    const competitorData = {
      keyword,
      timestamp: new Date().toISOString(),
      rankings: []
    };
    
    // Check our position
    const ourRanking = await simulateRankingCheck(keyword, 'emvi.app');
    competitorData.rankings.push(ourRanking);
    
    // Check competitor positions
    for (const competitor of competitors.direct_competitors.slice(0, 3)) {
      const domain = new URL(competitor.url).hostname;
      const ranking = await simulateRankingCheck(keyword, domain);
      competitorData.rankings.push(ranking);
      
      // Rate limiting
      await new Promise(resolve => setTimeout(resolve, 100));
    }
    
    results.push(competitorData);
  }
  
  return results;
}

async function analyzeRankingChanges(currentData, previousData) {
  if (!previousData) return [];
  
  const changes = [];
  
  for (const current of currentData) {
    const previous = previousData.find(p => 
      p.keyword === current.keyword && 
      p.rankings.some(r => r.site === 'emvi.app')
    );
    
    if (previous) {
      const currentPos = current.rankings.find(r => r.site === 'emvi.app')?.position;
      const previousPos = previous.rankings.find(r => r.site === 'emvi.app')?.position;
      
      if (currentPos && previousPos && Math.abs(currentPos - previousPos) > 3) {
        changes.push({
          keyword: current.keyword,
          previous_position: previousPos,
          current_position: currentPos,
          change: previousPos - currentPos, // Positive = improvement
          severity: Math.abs(currentPos - previousPos) > 10 ? 'high' : 'medium'
        });
      }
    }
  }
  
  return changes;
}

async function generateIssues(changes) {
  const criticalChanges = changes.filter(c => c.severity === 'high' && c.change < -5);
  
  if (criticalChanges.length === 0) {
    console.log('‚úÖ No critical ranking drops detected');
    return [];
  }
  
  const issues = [];
  
  for (const change of criticalChanges) {
    issues.push({
      title: `SEO Alert: Keyword "${change.keyword}" dropped ${Math.abs(change.change)} positions`,
      body: `## Keyword Ranking Alert

**Keyword:** ${change.keyword}
**Previous Position:** #${change.previous_position}
**Current Position:** #${change.current_position}
**Change:** ${change.change} positions
**Severity:** ${change.severity}

### Suggested Actions:
- [ ] Review content quality for this keyword
- [ ] Check for technical SEO issues
- [ ] Analyze competitor content improvements
- [ ] Consider content refresh or optimization

*Auto-generated by Keyword Tracker on ${new Date().toLocaleString()}*`,
      labels: ['seo-alert', 'keyword-tracking']
    });
  }
  
  return issues;
}

async function loadPreviousData() {
  const files = fs.readdirSync(CACHE_DIR)
    .filter(f => f.startsWith('keywords-') && f.endsWith('.json'))
    .sort()
    .reverse();
  
  if (files.length === 0) return null;
  
  const latestFile = path.join(CACHE_DIR, files[0]);
  return JSON.parse(fs.readFileSync(latestFile, 'utf8'));
}

async function main() {
  console.log('üîç Starting Keyword Position Tracking');
  
  const keywords = await loadKeywords();
  const competitors = await loadCompetitors();
  
  // Track all keyword types
  const allKeywords = [
    ...keywords.head_keywords,
    ...keywords.long_tail_keywords.slice(0, 5), // Limit for simulation
    ...keywords.location_keywords.slice(0, 3)
  ];
  
  console.log(`üìã Tracking ${allKeywords.length} keywords`);
  
  // Check rankings
  const rankingData = await checkCompetitorRankings(allKeywords, competitors);
  
  // Load previous data for comparison
  const previousData = await loadPreviousData();
  
  // Analyze changes
  const changes = await analyzeRankingChanges(rankingData, previousData?.rankings);
  
  // Generate GitHub issues for critical changes
  const issues = await generateIssues(changes);
  
  // Save results
  const date = new Date().toISOString().split('T')[0];
  const results = {
    timestamp: new Date().toISOString(),
    date,
    keywords_tracked: allKeywords.length,
    rankings: rankingData,
    changes,
    issues_created: issues.length,
    summary: {
      total_keywords: allKeywords.length,
      position_changes: changes.length,
      critical_drops: changes.filter(c => c.change < -5).length,
      improvements: changes.filter(c => c.change > 3).length
    }
  };
  
  const outputFile = path.join(CACHE_DIR, `keywords-${date}.json`);
  fs.writeFileSync(outputFile, JSON.stringify(results, null, 2));
  
  console.log('\nüîç Keyword Tracking Complete');
  console.log(`üìÅ Saved to: ${outputFile}`);
  console.log(`üìä Keywords tracked: ${results.keywords_tracked}`);
  console.log(`üìà Position changes: ${results.changes.length}`);
  console.log(`üö® Issues to create: ${results.issues_created}`);
  
  if (changes.length > 0) {
    console.log('\nüìä Notable Changes:');
    changes.forEach(change => {
      const direction = change.change > 0 ? 'üìà' : 'üìâ';
      console.log(`${direction} ${change.keyword}: #${change.previous_position} ‚Üí #${change.current_position}`);
    });
  }
  
  return {
    output_file: outputFile,
    keywords_tracked: allKeywords.length,
    changes: changes.length,
    issues: issues
  };
}

if (import.meta.url === `file://${process.argv[1]}`) {
  main().catch(error => {
    console.error('‚ùå Keyword tracking failed:', error);
    process.exit(1);
  });
}

export { main as trackKeywords };